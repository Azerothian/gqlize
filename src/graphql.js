
import {
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLList,
  // GraphQLString,
  GraphQLInputObjectType,
  GraphQLNonNull,
  GraphQLBoolean,
}
from "graphql";
import {
  resolver,
  defaultListArgs,
  defaultArgs,
  attributeFields,
  // typeMapper,
}
from "graphql-sequelize";

function resetInterfaces(impl) {
  delete impl._interfaces; //eslint-disable-line
  impl.getInterfaces().forEach(type => {
    type._implementations.push(impl); //eslint-disable-line
  });
}

function createBaseType(modelName, models, options) {
  let opts = options[modelName] || {};
  let fields = attributeFields(models[modelName], {
    exclude: opts.ignoreFields || [],
  });
  let resolve;
  if (opts.resolver) {
    resolve = opts.resolver;
  } else {
    resolve = resolver(models[modelName], {
      before: opts.before,
      after: opts.after,
    });
  }
  return new GraphQLObjectType({
    name: modelName,
    description: "",
    fields: fields,
    resolve: resolve,
  });
}
function createBeforeAfter(modelOpts, options) {
  let targetBeforeFuncs = [], targetAfterFuncs = [];
  if (options.before) {
    targetBeforeFuncs.push(options.before);
  }
  if (options.after) {
    targetAfterFuncs.push(options.after);
  }
  if (modelOpts) {
    if (modelOpts.before) {
      targetBeforeFuncs.push(modelOpts.before);
    }
    if (modelOpts.after) {
      targetAfterFuncs.push(modelOpts.after);
    }
  }
  const targetBefore = (findOptions, args, context, info) => {
    if (targetBeforeFuncs.length === 0) {
      return findOptions;
    }
    const results = targetBeforeFuncs.reduce((prev, curr) => {
      return curr(prev, args, context, info);
    }, findOptions);
    return results;
  };
  const targetAfter = (result, args, context, info) => {
    if (targetAfterFuncs.length === 0) {
      return result;
    }
    return targetAfter.reduce((prev, curr) => {
      return curr(prev, args, context, info);
    }, result);
  };
  const targetAfterArray = (results, args, context, info) => {
    if (targetAfterFuncs.length === 0) {
      return results;
    }
    return results.map((result) => {
      return targetAfter(result, args, context, info);
    });
  };


  return {
    before: targetBefore,
    after: targetAfter,
    afterList: targetAfterArray,
  };
}

function generateTypes(models, keys, options = {}) {
  let typeCollection = {};
  keys.forEach((modelName) => {
    typeCollection[modelName] = createBaseType(modelName, models, options);
    typeCollection[modelName].model = models[modelName];
  });
  keys.forEach((modelName) => {
    if (models[modelName].relationships) {
      let {fields} = typeCollection[modelName]._typeConfig; //eslint-disable-line
      Object.keys(models[modelName].relationships).forEach((relName) => {
        let relationship = models[modelName].relationships[relName];
        let targetType = typeCollection[relationship.source];
        let targetOpts = options[relationship.source];
        const {before, after, afterList} = createBeforeAfter(targetOpts, options);
        if (!targetType) {
          throw `targetType ${targetType} not defined for relationship`;
        }
        switch (relationship.type) {
          case "belongsToMany": //eslint-disable-line
          case "hasMany":
            fields[relName] = {
              type: new GraphQLList(targetType),
              args: defaultListArgs(),
              resolve: resolver(relationship.rel, {
                before,
                after: afterList,
              }),
            };
            break;
          case "hasOne": //eslint-disable-line
          case "belongsTo":
            fields[relName] = {
              type: targetType,
              resolve: resolver(relationship.rel, {
                before,
                after,
              }),
            };
            break;
          default:
            throw "Unhandled Relationship type";
        }
      });
      typeCollection[modelName]._typeConfig.fields = fields;//eslint-disable-line
      resetInterfaces(typeCollection[modelName]);
    }
  });
  return typeCollection;

}

function createQueryLists(models, keys, typeCollection, fields, options) {
  keys.forEach((key) => {
    let targetOpts = options[key];
    const {before, after} = createBeforeAfter(targetOpts, options);
    fields[key] = {
      type: new GraphQLList(typeCollection[key]),
      args: defaultListArgs(),
      resolve: resolver(models[key], {
        before,
        after,
      }),
    };
  });
  return fields;
}


function createMutationInput(modelName, model, gqlFields, prefix, allOptional = false) {
  let fields = {};
  Object.keys(gqlFields).forEach((fieldName) => {
    const sqlFields = model.fieldRawAttributesMap;
    if (sqlFields[fieldName]) {
      if (!sqlFields[fieldName]._autoGenerated && !sqlFields[fieldName].autoIncrement) { //eslint-disable-line
        let gqlField = gqlFields[fieldName];
        if (allOptional) {
          if (gqlField.type instanceof GraphQLNonNull) {
            gqlField = {type: gqlField.type.ofType};
          }
        }
        fields[fieldName] = gqlField;
      }
    }
  });

  return new GraphQLInputObjectType({
    name: `${modelName}${prefix}Input`,
    fields,
  });
}

function createMutationFunctions(models, keys, typeCollection, mutationCollection, userProfile) {
  keys.forEach((modelName) => {
    let {fields} = typeCollection[modelName]._typeConfig; //eslint-disable-line
    let requiredInput = createMutationInput(modelName, models[modelName], fields, "Required");
    let optionalInput = createMutationInput(modelName, models[modelName], fields, "Optional", true);
    let mutationFields = {
      create: {
        type: typeCollection[modelName],
        args: {
          input: {
            type: requiredInput,
          },
        },
        resolve(_, {input}, req, info) {
          return models[modelName].create(input, {user: req.user});
        },
      },
      update: {
        type: typeCollection[modelName],
        args: Object.assign(defaultArgs(models[modelName]), {input: {type: optionalInput}}),
        resolve: resolver(models[modelName], {
          after: (item, {input}, req, gql) => {
            return item.save(input, {user: req.user});
          },
        }),
      },
      delete: {
        type: GraphQLBoolean,
        args: defaultArgs(models[modelName]),
        resolve: resolver(models[modelName], {
          after: function(items, args, req, gql) {
            return Promise.all(items.map((item) => item.destroy({user: req.user})))
              .then(() => true);
          },
        }),
      },
      updateAll: {
        type: new GraphQLList(typeCollection[modelName]),
        args: Object.assign(defaultListArgs(models[modelName]), {input: {type: optionalInput}}),
        resolve: resolver(models[modelName], {
          after: (items, args, req, gql) => {
            return Promise.all(items.map((item) => item.save({}, {user: req.user})));
          },
        }),
      },
      deleteAll: {
        type: GraphQLBoolean,
        args: defaultListArgs(models[modelName]),
        resolve: resolver(models[modelName], {
          after: function(items, args, req, gql) {
            return Promise.all(items.map((item) => item.destroy({user: req.user})))
              .then(() => true);
          },
        }),
      },
    };
    const {mutations} = ((models[modelName].schema.expose || {}).classMethods || {});
    if (mutations) {
      Object.keys(mutations).forEach((methodName) => {
        const {type, args, roles = []} = mutations[methodName];
        if (roles.indexOf(userProfile) > -1) {
          let outputType = (type instanceof String || typeof type === "string") ? typeCollection[type] : type;
          mutationFields[methodName] = {
            type: outputType,
            args,
            resolve(item, args, req, gql) {
              return models[modelName][methodName].apply(models[modelName], [args, req]);
            },
          };
        }
      });
    }

    mutationCollection[modelName] = {
      type: new GraphQLObjectType({
        name: `${modelName}Mutator`,
        fields: mutationFields,
      }),
      resolve() {
        return {}; // forces graphql to resolve the fields
      },
    };
  });
  return mutationCollection;
}

function createQueryFunctions(models, keys, typeCollection, userProfile) {
  let queryCollection = {};
  keys.forEach((modelName) => {
    let {fields} = typeCollection[modelName]._typeConfig; //eslint-disable-line
    const {query} = ((models[modelName].schema.expose || {}).classMethods || {});
    let queryFields = {};
    if (query) {
      Object.keys(query).forEach((methodName) => {
        const {type, args} = query[methodName];
        let outputType = (type instanceof String || typeof type === "string") ? typeCollection[type] : type;
        queryFields[methodName] = {
          type: outputType,
          args,
          resolve(item, args, req, gql) {
            return models[modelName][methodName].apply(models[modelName], [args, req]);
          },
        };
      });
      queryCollection[modelName] = {
        type: new GraphQLObjectType({
          name: `${modelName}Query`,
          fields: queryFields,
        }),
        resolve() {
          return {}; // forces graphql to resolve the fields
        },
      };
    }
  });
  return queryCollection;
}

export default function createSchema(instance, fields = {}, mutations = {}, options = {}, userProfile) {
  let validKeys = Object.keys(instance.models).reduce((o, key) => {
    if (instance.models[key].schema) {
      // o[key] = instance.models[key];
      o.push(key);
    }
    return o;
  }, []);
  let typeCollection = generateTypes(instance.models, validKeys, options);
  let mutationCollection = createMutationFunctions(instance.models, validKeys, typeCollection, mutations, userProfile);
  let queryCollection = createQueryFunctions(instance.models, validKeys, typeCollection, userProfile);
  fields = createQueryLists(instance.models, validKeys, typeCollection, fields, options);
  const rootFields = Object.assign({
    models: {
      type: new GraphQLObjectType({name: "Models", fields: fields}),
      resolve() {
        return {};
      },
    },
  }, queryCollection);
  return new GraphQLSchema({
    query: new GraphQLObjectType({
      name: "RootQuery",
      fields: rootFields,
    }),
    mutation: new GraphQLObjectType({
      name: "Mutation",
      fields: mutationCollection,
    }),
  });
}
